from itertools import combinations
from operator import itemgetter

import numpy as np

def I_matr(n): #ÐµÐ´Ð¸Ð½Ð¸Ñ‡Ð½Ð°Ñ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ‹
    M = np.zeros((n, n), int)
    for i in range(n):
        M[i, i] = 1
    return M

def Cnk(n, k):
    return (fact(n) / (fact(k) * fact(n-k))).__int__()

def fact(n):
    res = 1
    if n > 0:
        for i in range (1, n+1):
            res *= i
        return res
    else:
        return res

def all_comb(n): #Ð²ÑÐµ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹Ðµ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°Ñ†Ð¸Ð¸ 0 Ð¸ 1 Ð² Ð²ÐµÐºÑ‚Ð¾Ñ€Ð°Ñ… Ñ€Ð°Ð·Ð¼ÐµÑ€Ð½Ð¾ÑÑ‚Ð¸ n
    res = []
    for i in range(2 ** n):
        s = []
        for j in range(n):
            s.append(i % 2)
            i = i // 2
        res.append(s)
    res = np.asarray(res)   # Ð² Ð´Ð°Ð½Ð½Ð¾Ð¹ Ñ€Ð°Ð±Ð¾Ñ‚Ðµ Ð±ÑƒÐ´ÐµÐ¼ Ð½Ð°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ñ‹Ð¼ Ð¿Ð¾Ñ€ÑÐ´ÐºÐ¾Ð¼
    return res

def all_I(r, m):           # ÐÐ°Ð¹Ð´ÐµÐ¼ Ð²ÑÐµ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹Ðµ I Ð´Ð»Ð¸Ð½Ñ‹ Ð´Ð¾ r Ð¸ ÑÐ¾Ñ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð¸Ñ… Ð² Ð½ÑƒÐ¶Ð½Ð¾Ð¼ Ð¿Ð¾Ñ€ÑÐ´ÐºÐµ
    res = []
    res.append([])      # ÐŸÐµÑ€Ð²Ñ‹Ð¼ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð¼ Ð²ÑÐµÐ³Ð´Ð° Ð±ÑƒÐ´ÐµÑ‚ Ð¿ÑƒÑÑ‚Ð¾Ðµ Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ð¾
    I = []
    for i in range(m):  # Ð—Ð°Ð¿Ð¾Ð»Ð½Ð¸Ð¼ I Ñ‡Ð¸ÑÐ»Ð°Ð¼Ð¸, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ ÑÐ¾Ð±Ð¸Ñ€Ð°ÐµÐ¼ÑÑ ÑÐ¾Ñ‡ÐµÑ‚Ð°Ñ‚ÑŒ (Ð¾Ñ‚ 0 Ð´Ð¾ n)
        I.append(i)
    curr = []
    for k in range(1, r+1):     # Ð”Ð»Ñ k Ð¾Ñ‚ 0 (Ñ‚.Ðº. Ð½ÑƒÐ»ÐµÐ²Ð¾Ð¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚ - ÑÑ‚Ð¾ Ð¿ÑƒÑÑ‚Ð¾Ðµ Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ð¾) Ð´Ð¾ r-1 Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾
        curr.append([*combinations(I, k)])   # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð² res Ð²ÑÐµ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹Ðµ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°Ñ†Ð¸Ð¸ Ð¸Ð· I Ð¿Ð¾ k ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²
        curr[0].reverse()        # ÐšÐ°Ð¶Ð´Ñ‹Ð¹ "Ð±Ð»Ð¾Ðº" (Ð¿Ð¾ 1, 2, 3 Ð¸ Ñ‚.Ð´. ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²) Ð±ÐµÑ€ÐµÐ¼ Ð² Ð¾Ð±Ñ€Ð°Ñ‚Ð½Ð¾Ð¼ Ð¿Ð¾Ñ€ÑÐ´ÐºÐµ
        curr[0].sort(key=itemgetter(k - 1), reverse=True)    # Ð’ ÑÐ»ÑƒÑ‡Ð°Ðµ, ÐµÑÐ»Ð¸ Ð±ÑƒÐ´ÐµÑ‚ Ñ‚Ð°ÐºÐ¾Ðµ, Ñ‡Ñ‚Ð¾ ÑÑƒÐ¼Ð¼Ð° ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² Ð² ÑÐ¾ÑÐµÐ´Ð½Ð¸Ñ… I Ñ€Ð°Ð²Ð½Ð°,
                                                            # Ð½Ð¾ Ð¿Ð¾Ñ€ÑÐ´Ð¾Ðº Ð½Ðµ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚Ð¸
                                                            # Ñ‚.Ðµ. ÑÑ‚Ð°Ñ€ÑˆÐ¸Ðµ Ñ€Ð°Ð·Ñ€ÑÐ´Ñ‹ ÑÑ‚Ð¾ÑÑ‚ Ð¿Ð¾Ð·Ð¶Ðµ, Ñ‡ÐµÐ¼ Ð¼Ð»Ð°Ð´ÑˆÐ¸Ðµ
                                                            # Ð¾Ñ‚ÑÐ¾Ñ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ð¾ ÑÑ‚Ð°Ñ€ÑˆÐ¸Ð¼ Ñ€Ð°Ð·Ñ€ÑÐ´Ð°Ð¼
        for j in range(Cnk(len(I), k)):
            res.append(curr[0][j])
        curr = []
    return res

def k_rm(r, m):     # Ñ€Ð°Ð·Ð¼ÐµÑ€Ð½Ð¾ÑÑ‚ÑŒ ÐºÐ¾Ð´Ð° Ð Ð¸Ð´Ð°-ÐœÐ¸Ð»Ð»ÐµÑ€Ð°
    sum = 0
    for i in range(r+1):
        sum += Cnk(m, i)
    return sum

def rm_G(r, m):     # ÐŸÐ¾Ñ€Ð¾Ð¶Ð´Ð°ÑŽÑ‰Ð°Ñ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ð° ÐºÐ¾Ð´Ð° Ð Ð¸Ð´Ð°-ÐœÐ°Ð»Ð»ÐµÑ€Ð° Ð² ÐºÐ°Ð½Ð¾Ð½Ð¸Ñ‡. Ð²Ð¸Ð´Ðµ
    res = np.zeros((k_rm(r, m), 2 ** m), int)
    t = 0
    for i in all_I(r, m):
        res[t] = find_v(i, m)
        t += 1
    return res

def find_v(I, m):   # Ð½Ð°Ð¹Ð´ÐµÐ¼ Ð²ÐµÐºÑ‚Ð¾Ñ€ v_I
    if len(I) == 0:     # Ð•ÑÐ»Ð¸ I - Ð¿ÑƒÑÑ‚Ð¾Ðµ Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ð¾, Ñ‚Ð¾
        return np.ones(2 ** m, int)     # Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð²ÐµÐºÑ‚Ð¾Ñ€ ÐµÐ´Ð¸Ð½Ð¸Ñ† Ð´Ð»Ð¸Ð½Ð½Ð¾Ð¹ 2^m, ÑÐ¾Ð³Ð»Ð°ÑÐ½Ð¾ Ñ„Ð¾Ñ€Ð¼ÑƒÐ»Ðµ
                                        # f_I (x0, x1, â€¦ , xð‘šâˆ’1) = 1, ÐµÑÐ»Ð¸ I = âˆ….
    j = 0
    res = np.zeros(2 ** m, int)                        # Ð•ÑÐ»Ð¸ I â‰  âˆ…
    for x in all_comb(m):            # ÐŸÑ€Ð¾Ð¹Ð´ÐµÐ¼ÑÑ Ð¿Ð¾ Ð²ÑÐµÐ¼ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°Ñ†Ð¸ÑÐ¼ ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾Ð³Ð¾ Ð¿Ð¾Ñ€ÑÐ´ÐºÐ°
        f = 1
        for i in I:                  # ÐŸÐ¾ Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ñƒ I Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð½Ð´ÐµÐºÑÐ¾Ð², ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ Ð¿Ñ€Ð¸Ð½ÑÐ»Ð¸ Ð½Ð° Ð²Ñ…Ð¾Ð´
            f *= (x[i] + 1) % 2      # f = ÐŸ (ð‘¥ð‘– + 1), Ð³Ð´Ðµ + ÑÑ‚Ð¾ ÑÐ»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð¿Ð¾ Ð¼Ð¾Ð´ÑƒÐ»ÑŽ 2,  i Ð¿Ñ€Ð¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð¸Ñ‚ I
        res[j] = f               # ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ð²ÑˆÑƒÑŽÑÑ Ð½Ð° ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ð¸Ñ‚ÐµÑ€Ð°Ñ†Ð¸Ð¸ f Ð·Ð°Ð¿Ð¸ÑÑ‹Ð²Ð°ÐµÐ¼ Ð² Ð²ÐµÐºÑ‚Ð¾Ñ€ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð²
        j += 1
    return res              # Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð²ÐµÐºÑ‚Ð¾Ñ€ v_I

def find_vt(I, m, t):   # Ð½Ð°Ð¹Ð´ÐµÐ¼ Ð²ÐµÐºÑ‚Ð¾Ñ€ v_It
    if len(I) == 0:     # Ð•ÑÐ»Ð¸ I - Ð¿ÑƒÑÑ‚Ð¾Ðµ Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ð¾, Ñ‚Ð¾
        return np.ones(2 ** m, int)     # Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð²ÐµÐºÑ‚Ð¾Ñ€ ÐµÐ´Ð¸Ð½Ð¸Ñ† Ð´Ð»Ð¸Ð½Ð½Ð¾Ð¹ 2^m, ÑÐ¾Ð³Ð»Ð°ÑÐ½Ð¾ Ñ„Ð¾Ñ€Ð¼ÑƒÐ»Ðµ
                                        # f_I (x0, x1, â€¦ , xð‘šâˆ’1) = 1, ÐµÑÐ»Ð¸ I = âˆ….

    res = []                         # Ð•ÑÐ»Ð¸ I â‰  âˆ…
    for x in all_comb(m):            # ÐŸÑ€Ð¾Ð¹Ð´ÐµÐ¼ÑÑ Ð¿Ð¾ Ð²ÑÐµÐ¼ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°Ñ†Ð¸ÑÐ¼ ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾Ð³Ð¾ Ð¿Ð¾Ñ€ÑÐ´ÐºÐ°
        f = 1
        for i in I:                  # ÐŸÐ¾ Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ñƒ I Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð½Ð´ÐµÐºÑÐ¾Ð², ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ Ð¿Ñ€Ð¸Ð½ÑÐ»Ð¸ Ð½Ð° Ð²Ñ…Ð¾Ð´
            f *= (x[i] + t[i] + 1) % 2      # f = ÐŸ (ð‘¥ð‘– + ti + 1), Ð³Ð´Ðµ + ÑÑ‚Ð¾ ÑÐ»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð¿Ð¾ Ð¼Ð¾Ð´ÑƒÐ»ÑŽ 2,  i Ð¿Ñ€Ð¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð¸Ñ‚ I
        res.append(f)                # ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ð²ÑˆÑƒÑŽÑÑ Ð½Ð° ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ð¸Ñ‚ÐµÑ€Ð°Ñ†Ð¸Ð¸ f Ð·Ð°Ð¿Ð¸ÑÑ‹Ð²Ð°ÐµÐ¼ Ð² Ð²ÐµÐºÑ‚Ð¾Ñ€ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð²
    # print("v {", I, "} {",  t,  "}", res)
    return res              # Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð²ÐµÐºÑ‚Ð¾Ñ€ v_It

def _c(I, m):   # ÐÐ°Ñ…Ð¾Ð¶Ð´ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð¼Ð¿Ð»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ñ€Ð½Ñ‹Ð¼ Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ð¾Ð¼ Ðº Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ñƒ I Ð½Ð° Zm
    res = []
    for i in range(m):
        if i not in I:
            res.append(i)
    return res

def find_H_I(I, m):
    res = []
    for x in all_comb(m):  # ÐŸÑ€Ð¾Ð¹Ð´ÐµÐ¼ÑÑ Ð¿Ð¾ Ð²ÑÐµÐ¼ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°Ñ†Ð¸ÑÐ¼ ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾Ð³Ð¾ Ð¿Ð¾Ñ€ÑÐ´ÐºÐ°
        f = 1
        for i in I:  # ÐŸÐ¾ Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ñƒ I Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð½Ð´ÐµÐºÑÐ¾Ð², ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ Ð¿Ñ€Ð¸Ð½ÑÐ»Ð¸ Ð½Ð° Ð²Ñ…Ð¾Ð´
            f *= (x[i] + 1) % 2  # f = ÐŸ (ð‘¥ð‘– + 1), Ð³Ð´Ðµ + ÑÑ‚Ð¾ ÑÐ»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð¿Ð¾ Ð¼Ð¾Ð´ÑƒÐ»ÑŽ 2,  i Ð¿Ñ€Ð¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð¸Ñ‚ I
        if f == 1:
            res.append(x)  # ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ð²ÑˆÑƒÑŽÑÑ Ð½Ð° ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ð¸Ñ‚ÐµÑ€Ð°Ñ†Ð¸Ð¸ f Ð·Ð°Ð¿Ð¸ÑÑ‹Ð²Ð°ÐµÐ¼ Ð² Ð²ÐµÐºÑ‚Ð¾Ñ€ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð²
    return res

def major(w, r, m):
    i = r
    curr_w = w
    dead_edge = 2 ** (m - r - 1) - 1
    mi = []
    check = True

    while check:
        for J in lgth(m, i):
            edge = 2 ** (m - i - 1)
            zero = 0
            one = 0
            for t in find_H_I(J, m):
                c = np.dot(curr_w, find_vt(_c(J, m), m, t)) % 2
                if c == 0:
                    zero += 1
                if c == 1:
                    one += 1
            if zero > dead_edge and one > dead_edge:
                print("ÐÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð° Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð½Ð°Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ° ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ")
                return
            if zero > edge:
                mi.append(0)
            if one > edge:
                mi.append(1)
                curr_w = (curr_w + find_v(J, m)) % 2
        if i > 0:
            if len(curr_w) < dead_edge:
                for J in lgth(m, r+1):
                    mi.append(0)
                    check = False
            i -= 1
        else:
            check = False
    mi.reverse()
    return mi

def lgth(m, l):
    I = []
    for i in range(m):
        I.append(i)
    cur = []
    cur.append([*combinations(I, l)])
    if len(cur[0][0]) != 0:
        cur[0].sort(key=itemgetter(len(cur[0][0])-1))
    res = []
    for i in range(len(cur[0])):
        res.append(cur[0][i])
    return res

def rand_word(n): #Ñ€Ð°Ð½Ð´Ð¾Ð¼Ð½Ð¾Ðµ ÑÐ»Ð¾Ð²Ð¾ Ð´Ð»Ð¸Ð½Ñ‹ n
    return np.random.randint(0, 2, n)

def createError(n, t):  #ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð²ÐµÐºÑ‚Ð¾Ñ€Ð° Ð¾ÑˆÐ¸Ð±Ð¾Ðº
    error = np.zeros(n, int)
    errorNum = np.zeros(t, int)
    for i in range (0, t):
        errorNum[i] = np.random.randint(0, n)
    for i in range(t):
        error[errorNum[i]] = 1
    return error


if __name__ == '__main__':
    m = 4
    r = 2
    G = rm_G(r, m)
    print("ÐŸÐ¾Ñ€Ð¾Ð¶Ð´Ð°ÑŽÑ‰Ð°Ñ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ð° : \n", G)

    U = rand_word(k_rm(r, m))
    print("Ð¡Ð»Ð¾Ð²Ð¾ Ð´Ð»Ð¸Ð½Ñ‹ k: \n", U)
    V = np.dot(U, G) % 2
    print("KÐ¾Ð´Ð¾Ð²Ð¾Ðµ ÑÐ»Ð¾Ð²Ð¾ Ð´Ð»Ð¸Ð½Ñ‹ n: \n", V)

    for i in range(1, 3):
        Err = createError(2**m, i)
        print(i, "-ÐºÑ€Ð°Ñ‚Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°: \n", Err)
        W = (V + Err) % 2
        print("Ð¡Ð»Ð¾Ð²Ð¾ Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ¾Ð¹: \n", W)

        Correct_W = major(W, r, m)
        if Correct_W:
            print("Ð˜ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð½Ð¾Ðµ ÑÐ»Ð¾Ð²Ð¾: \n", Correct_W)
            V1 = np.dot(Correct_W, G) % 2
            print("ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÑƒÐ¼Ð½Ð¾Ð¶Ð¸Ð² Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ð¹ Ð²ÐµÐºÑ‚Ð¾Ñ€ Ð½Ð° Ð¿Ð¾Ñ€Ð¾Ð¶Ð»Ð°ÑŽÑ‰ÑƒÑŽ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñƒ G(2,4): \n", V1)


    #print(all_comb(3))
    #I = {1, 2}
    #print(find_v(I, 3))
    #print(all_I(r))

    #w = [0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]
    #print("w = \n", w)
    #J = {0, 1}
    #print(_c(J, m))
    #print(find_H_I(J, m))
    #Correct_W = major(w, r, m)
    #print("Ð˜ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð½Ð¾Ðµ ÑÐ»Ð¾Ð²Ð¾: \n", Correct_W)
    #check = np.dot(Correct_W, G) % 2
    #print("ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÑƒÐ¼Ð½Ð¾Ð¶Ð¸Ð² Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ð¹ Ð²ÐµÐºÑ‚Ð¾Ñ€ Ð½Ð° Ð¿Ð¾Ñ€Ð¾Ð¶Ð»Ð°ÑŽÑ‰ÑƒÑŽ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñƒ G(2,4): \n", check)



   #for l in range(Cnk(n, k) - 1):
         #   if sum(res[k][l]) == sum(res[k][l+1]):
          #      res[k].sort(key=itemgetter(k-1), reverse=True)
                #if res[k][l][k-1] < res[k][l + 1][k-1]:
                    #res.insert()
                    #print(res[k][l][k-1], res[k][l+1][k-1])